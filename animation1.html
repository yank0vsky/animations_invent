<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Data Flow Animation</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      background: #f4f4f4;
      font-family: Arial, sans-serif;
    }
    canvas {
      display: block;
      margin: 0 auto;
      background: #ffffff;
      border: 2px solid #333;
    }
  </style>
</head>
<body>
<canvas id="myCanvas" width="800" height="500"></canvas>

<script>
/************************************************
 * Data Flow Simulation
 * Shows multiple data sources (custodians, PMS)
 * flowing into a central "storage" area, then
 * syncing and displaying on a final chart.
 ************************************************/

// Grab the canvas and context
const canvas = document.getElementById("myCanvas");
const ctx = canvas.getContext("2d");

// Data source objects with initial positions
const dataSources = [
  { name: "Orion", x: 50,  y: 50,  color: "#ff6f69" },
  { name: "Addepar", x: 50,  y: 150, color: "#ffcc5c" },
  { name: "Tamarac", x: 50,  y: 250, color: "#88d8b0" },
  { name: "eMoney", x: 50,  y: 350, color: "#96ceb4" },
];

// Storage box coordinates
const storageBox = {
  x: 300,  // top-left corner of the box
  y: 200,
  w: 200,
  h: 100
};

// Chart area coordinates on the right side
const chartArea = {
  x: 600,
  y: 100,
  w: 150,
  h: 300
};

// Animation state
let step = 0;
let frameCount = 0;

// Bar chart data once the circles reach the storage
const chartBars = [
  { label: "Client A", value: 0, target: 100 },
  { label: "Client B", value: 0, target: 150 },
  { label: "Client C", value: 0, target: 80 },
  { label: "Client D", value: 0, target: 120 },
];

// Draw the storage box
function drawStorageBox() {
  ctx.fillStyle = "#ddd";
  ctx.fillRect(storageBox.x, storageBox.y, storageBox.w, storageBox.h);
  ctx.strokeStyle = "#666";
  ctx.lineWidth = 2;
  ctx.strokeRect(storageBox.x, storageBox.y, storageBox.w, storageBox.h);

  ctx.fillStyle = "#333";
  ctx.font = "16px Arial";
  ctx.fillText("Client & Account Data Storage", storageBox.x + 10, storageBox.y + 55);
}

// Draw the chart area outline
function drawChartArea() {
  ctx.strokeStyle = "#666";
  ctx.lineWidth = 2;
  ctx.strokeRect(chartArea.x, chartArea.y, chartArea.w, chartArea.h);

  ctx.fillStyle = "#333";
  ctx.font = "16px Arial";
  ctx.fillText("Chart", chartArea.x + 40, chartArea.y - 10);
}

// Draw the bar chart
function drawChartBars() {
  // We have chartBars with { label, value, target }
  const barWidth = 20;
  const gap = 15;
  let startY = chartArea.y + 20;

  for (let i = 0; i < chartBars.length; i++) {
    const bar = chartBars[i];
    // Update value to move toward target
    if (bar.value < bar.target) {
      bar.value += 2; // speed of bar growth
      if (bar.value > bar.target) bar.value = bar.target;
    }

    // Draw bar
    ctx.fillStyle = "#3399ff";
    // bar height is bar.value
    ctx.fillRect(chartArea.x + 30, startY, bar.value, barWidth);

    // Label
    ctx.fillStyle = "#333";
    ctx.font = "14px Arial";
    ctx.fillText(bar.label, chartArea.x + 30 + bar.value + 10, startY + 15);

    startY += barWidth + gap;
  }
}

// Update each data source position
function updateDataSources() {
  dataSources.forEach((ds) => {
    // Move to storage
    if (step === 0) {
      const targetX = storageBox.x + storageBox.w / 2;
      const targetY = storageBox.y + storageBox.h / 2;
      ds.x += (targetX - ds.x) * 0.02;
      ds.y += (targetY - ds.y) * 0.02;

      // If close enough to the storage center, switch step
      if (Math.abs(ds.x - targetX) < 1 && Math.abs(ds.y - targetY) < 1) {
        ds.x = targetX;
        ds.y = targetY;
      }
    }
    // Move to chart area
    else if (step === 1) {
      const targetX = chartArea.x + chartArea.w / 2;
      const targetY = chartArea.y + chartArea.h / 2;
      ds.x += (targetX - ds.x) * 0.02;
      ds.y += (targetY - ds.y) * 0.02;

      // If close enough to the chart center, we might do final arrangement
      if (Math.abs(ds.x - targetX) < 1 && Math.abs(ds.y - targetY) < 1) {
        ds.x = targetX;
        ds.y = targetY;
      }
    }
  });
}

// Draw each data source circle
function drawDataSources() {
  dataSources.forEach((ds) => {
    ctx.beginPath();
    ctx.arc(ds.x, ds.y, 20, 0, Math.PI * 2);
    ctx.fillStyle = ds.color;
    ctx.fill();
    ctx.closePath();

    // Label
    ctx.fillStyle = "#000";
    ctx.font = "12px Arial";
    ctx.fillText(ds.name, ds.x - 20, ds.y - 25);
  });
}

// Main animation loop
function animate() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Draw static elements
  drawStorageBox();
  drawChartArea();

  // Step transitions
  if (step === 0 && frameCount > 200) {
    // After some frames, move to next step
    step = 1;
  }
  if (step === 1 && frameCount > 400) {
    // Once data is in chart area, start drawing chart bars
    drawChartBars();
  }

  // Update & draw data sources
  updateDataSources();
  drawDataSources();

  // If step >= 1, animate chart bars growth
  if (step >= 1 && frameCount > 400) {
    drawChartBars();
  }

  frameCount++;
  requestAnimationFrame(animate);
}

// Start animation
animate();
</script>
</body>
</html>
